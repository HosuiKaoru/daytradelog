<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"82e44307e547bb5825257a17bfb665ae11b2b115d67a26f954c83bb327ffd085612411ef315e1863817b1af9b19297e4898ca10d71c0998f43ab670593d6b1133c6daa1f05b619d98cd75ad83b9f072ac9669ae3cd28346fd6da2141dc852888ff27ec5da322ae34eba3712e1b7a0f6801ff729c89a456daa14dbb6ee2fa12a2c0e5503432fa8f6e797675216aafa1026703a74a829e5f12271e3217990f145cde141f6561fc23060b95af4346cfb08383581915a55a17771d9bb5f3fbb4a15b6160419713b146e57881ec73175d026ef05dc1fd2e316bee9e01e4733c83717033bcdff81e4a1add066b81df2a74e753417477d8a1d66250c0c4697877d0a23acb71c3017e8df8da95b8410145998b25fd60f3c17448ab9bb9a4b4189f00531d815dae03ef04c5aead80520f5d1addec42719abf10abc846b8615cacbfd473aba2a940780bbeea11d747e1a79c591c08e6affddef270801f33c5d2e0a5c52397e84723a49a0b679bc91d5e6f83c0ecf3b5012c09101c8dbec9020362ab38443e47d9c49d9a2d198e6697c49b846979fbfc795adefce0de422c8f1dce9a85d2cb98fd07c83b79a28db3ffe404cda57c5b9be964ae3768f1d7034e215047e4b1beabe1808f4ae1f57fcad1860adcf2657cbb6c0db2b2ab5adf2526426b7cf7e2d1a810202db772f09d4e65e5d2ba628c122a373d84b19d958469f960d986b64afef79eccfad867295bfab8ff8a99dc8849f97e05d8f6ff05925666b1b0098da4895198cf62643746079fbeac89cee401d4a7e54519a47b1b748b60fc2c49f36b9ed70ac067d7ccf95d379db58dd5e9be3377ce37cfb8a04c79a46f9a37da35a32eb4299a351b94c8bb197620073b667e9ac90e3c2b17f42a1ca4e4b41dca47320ee24b144f93445bb357ca47ca937f7da73f26943114f84237ae6d7cdec69a76f3b3a48ec4b32ca683d7b2648400fda4dbd8d74ed9f9240b1cf653279231a435c47a8540e9b252903f426a98a6de285dd3a778378f1d87f993d44cbc81f5e96d18c9b440a59bb803496c448b16ca90c679714afeb284912ecd999ff4bd64976d9c7396d96e50c59fb7e174cb966a07e13cf207bfd0d577def83e53e2d5c0fc642c08ff2ce9bdd03964ac51c1bbd121429a036ef673a336808a4bac79287adab4755bb16e8242671f063480ca5914a8f21c0eb53f295cb861c96e5157185c89230aecdf092d84f2558748910eab181a455b892ab7395f789b7b2e33061d24a45a4bfec1ffcb0551d709b3519b781319db48ef5ae16a053797d6415a9f7b0ade7b30f2f114fa74f6c4265d133dd5a46cac4276f9fe178dfb814d5720b6ef5ee09e084c5e544bae8aec5880d4ef15fe31fe3ea53c8c950c3d1ca065396a675b10ffcc0b729e8750a76ef9be8223042cc10930431f9bab720645427b19423fda0a9ad370ec8c718e5787bdbc0192bb7a08463eb947f8d807f73afcf13acee2ae8183c4b8b0bac73064ab95661fcfc3bb86d6dff6452babfcb7c6b581b9093adc7ae43497d83f59fe5af015db3cf061ec0ee2a03a98d8f4af9405d89fee36d1cb39bfcde160f003cc5a1e0692cbed652baec7bdc38d1f7723d2bfd5a72a8899591bf871dc47558fbf3e49658a8721ba19073cd7ca67301eae53236418d7fd139bd02b0aeab96d4d10e2307a930b0b0401b414b4a4f1e3c422eb1f5b5a16c0ba8eb9e0116c3dd29e4c4684528e038de83aad50c7e8db4a55469bb136da8fe0d48c024939536443791f8489c428324e818e1770ab41296b50e0ac66717b2a6625b9fd7a4874323d3b0279bf0b26ca27ad682d7a38410e0eef0aa1373ecc56916cad220c74e29b4c7a30e43fcc038d40a4ef658566e39a72b08ed4d029dedf1d1a3ee94c46c2e6bf448d10ca8ffc34c27adaf265cc3a605537e08cc8e64627e18eb0cd402e0d925477bedffbc3701a1be6df8485b54398bb98ad7d94a60249177c7fb4111a290fb6f664fb436d95c032396af242e9d0ef589820b5fcba1e8a61aa84348475ce2eba09f0d14823e9aec57be45dfac660b065a622a269c8771be8f42628188f03bfa83c8be7a2cadf8d2ce5f52c95e27c321ac76202148f49431e5c1580345b5b1f02be04abc8ff4234c7a580204ceda5927ac22ec64d01d157c9e70a4488a10111d2ff25a2a9e5443daa322992b704f3bf6941a42f7c9e64b4b3d8fa874e7a05e9b5b8a67a0240ed11f8bf807765588f9c8adc6d98e1feb7542bc19b087d88274c2db6d5aa6d48c95d77de30d628a5af1242c7c8e5c1248b9d8eefdc5235b141b7c672d24f8a2e0de8911c98baf73de176b2e80db1050d03a3fd78da0259e87fb9d2b685c086ba07f9cdffeba6a979e70ad4ea4fc32ba2803f2586b71c68fe37d70cd0a9fb9cba32b6c07edc21630db720709dff2de969e6faabb6a9edd46b1e02afffb89bb48363f9aab49ce9ce2fc13559020c58a0e10456098f261ca95116f724fa9d3441c15de05bc6dee6e447ae9bbc7d2c4fabc2148ebfa7e27985a72fb8a8e33229d1afe1c4bc23bf0a0d2dc6e7518e191fdeab7da8e2d04d0557fef1f6a057fac319be5d05761beb9cbfc60887b047e3929d705fcb65fc87c30329f2cae41b0d64fc2175c4c2682f1d5280cdd9ae772daa81d1cc4ad9ce3cf3c100eaf46070c4297106e3d8cf9fc0a26330872367f58de25e881b20fb551ff13834ab0ec31066037fb1877fe8fceb485d5e10b2cdeab19cf4e2911aebd755202ec31c61cb89f5253d3c77de2d6ff651c7cec2a4df9aaad6077a640c80fc4e5a4e02b6f010028947ff774da26469e5a793d507cb516c15987cbde88187d20200d26d1ab140f9688a41fe953cabef53bf0c6f4d8ddc2e20e4b7e3b31eafc44af61a4f5d6bbb7a57d29a2a19600f1c209058af607a120439bd6c0c7630ed97a0d99d09eaa69c9d998c6abc762e43b789527367d9300e0edf6b2c4c97a8cbc78229f46ec096f0be787393e9cc3b8d6eaeee9d0b24d518b1f3105abf32a9707484ba28960e0dab33cc12157da23c1792054337ee61e3be03f8fb67d100f0a7515161236bdaf1c2f50792bc47b0a209789324c16616c1c473e73c56b40dcd88732948e7b3ba2f49bd2c5fdd489194f21bb6c3a289d7bf9802eb5eff74ed8810e55aa9bfa0e70837ee1db65ae1e7aedf096a53a5fae938b4d8991f688406307459776427eceab65a345b4989ed60371fb8d07b3cecce7c7eee4fcd9cdffa8e3dc8878ddbbd2051c6dc2e3562fa88fc3d8d3939df13db9189895bc1a6ed1612ba4ab9e65d5c055642f678ffbea08f7ac356f581bb4a4b277196d58f8c93cb64bf4ca8d59fb98746980178019d4dd41e80fc1d8399903e86a13675d3525e370a198e1ea8099eb49239190e16e5bdee06869b851844c14acf198870de9bf3e2c7bc0f687bcb67eea006ed50faa161442a599cbacdcb2b5acfe8aa269d2cbf1399d35d01df7ad9b7741512f8a3578fa457103800010d24f6e7eb3f9d9d8b7d3ba498a8ca3ebe989c8a9a784d55a292f64d5df50b57c6ca15549384d7a648cd69cb8587867cc5a63a82651f55622a6b1e1a956ca0088530b5faf7a20adb99db743124296c005e8be17585ee596356f385081551126aa8b2a65240ee62e2050e73b44a3ef0227b9517bf12f3ac0b060e4ceed7cf0e62a37c12b037073f774ec208610a9bb5478faa06dbd5f6abbad0ba82466395738d3ecdd1628960029489117ebe5ad7b655eb94cde75b6ae5d2cf0556d9df741be39edc655ac3dfaa59b3a042a82704087a45bd2c8e5c66726ee9debda47d7797c53c9e374ea447ecbe79438e0855832c3a3feff7b694b0d457392f791cb67ed6c4f49e63640ede5e4f55fddf12efe6eb546d68f1f3f2337635986287331b544ece087479fbaf7b4e3ae5c93cd5a0131169fd4af2877db21a166d81dbfaa6eada441f3557bd159cda450af2de92dfc203bbe2e9901bb7287acbe43112da6dd1fd48dc39d0311f461a315ff87731ed64c7c5448add644c5871f251b00ebe737598ca904131fa6d15b43463b07d07289ee89c8071a99a47873c01350a51e4b4b724a61b89d1015fde53454c4d1eb5ab92abdbabcb0564e978d3781f6a59b4d1a17b2b67c9f521b9ee47e223c591da679c3f696e86999a3e789ac85cbf4407792778a9806fe632bf1b7b3a5e87c7a6482cda5ff01d7165c404e2334e45463ccc652ac594ef8ddf1b21954fa46743da6d5e972f0220838b5a2231d6639b08454a8ed4e20da4b37f73e699cc7b33f04f361941f5f207679fc6d8f6e842baca47a6141ccd152b94aadd6b27cd8edee6f8a52289c0c45bade44537bbe4e9ae01b0b29684068e83fb2338851f9f1ab868bdadb79d1f27727c73e8ff53101518fa655d3dfe08f295de30e946be3de8d25d2f16fc8a69be23764f2cb35da84dce18231c31814b357d3c2e848acf59b80a7be009c1fac58a8698327533f20c3bd968c141ed226f8b71b7118126e9c4e3f3da30680c8fbdf0d15f08ce3248b70c4e7d0d35a6b0135e21a7aea16314a13b2e726e4c797287f43d4a7e6058c7966706b01bf9a894f8f165057858f4bc5eaf8d25f55205224a705623ddcca55b9cab8d2363682ed70d3b030ce0e18f6a595addf4ecbaebc01ab4fa61e77ae470316208d2ea76e3d2bb8cd7d061a4b07c854b5afb3d61c1baabbfce87069efdab326181b5ebbe976ec728358f4061840b608992c5ef93f511feae5b6de4408393628551d8812fdc60125e49537d8e564babe907674f7b9d10178dc03b1555c64e2166d1600257acb17acd91b94163d79eeaebb45be213b1c8be813bca977c71603a9dd4695a902e3dbb804a51f6385c4c6480f5ec295c8a5ffa20e2da6cd75a6d9f1911c95384d51a5a2632c78971343dd1741c82b2786ab1832d4fe8afe5bee863ff8674ff8ab2ea3577a3bfefa52dd2b1b306691db9d7699f08503f22717b197fda0aac0208bf963b826e2f55a1c8283caa31aa7e5d2be28f8c56d73e78ef274d562f844448cab99c6a633885fc75a97f627b4e5ff77ade474c7590d8d6b233f20261784e840fac2a08fc41339addf0e344b3f696950e6cf2ce6aea76b1b63181c87d6e332de9e43ff6dc21f7452c87af0f60c1a9f28b1b528f566321082beff7e6d07dc399d3933dbb71e1a4179882c451db6800671b6ed4c67bd266c042a4131f35c9e8206cf0266fab9c067b11d86de095fa2c923c3a8b5ee8515958984d09faaaa134408546c5ba0f1fe9d47ad1a4851fae34cbbd1b5b024dd9c106144a190aaf480d5dee397c09e631e8ce944ba5f79a816858f52d5f7a5623b9c7540405c730dff1cc8f06f76d5e58330c7ac8385655cacc13fbb34296e72008800e2320ee8c2ab6b9737dd0f966a5498c7c2153bdf767e72e66e12ce6c5fae82d494617ab5fd7266bb19ed89aa0556ae892afa22e5625eaf7880d6a5ffb7133b19b96441ef4530f84d5d5894e766129dad7767a9d5bc302b0e21f16e3b6f8105fb5c951d06a7f1ee3b4f3e8004a66f23675b12947a3b4a7fbb9d3d30ae5727e8303ac74598864a745044da316e784a042ee8280243fcb105a5a28c0e688d961784f63d68a520c8d0b811c25a14184b019ea2ee14cdb38fc030fd461175a18bdeba25100d2971ae44fe3acb24224b00906ae3b0dfc8d505494386ed7010b1153f5ea95b868fc85e2140ec35c485b79fd6e4802af90d30983740812e1ab779f7d46300b79e004c420a21d643b58b6e9527548162021dcdd01c968281165eb1e44a39fbd28add380fc3f5b1982b82e5fecc8ae77307acec38527cb4abf360e17dd3059b77d3772029c7ba6f4bc25cdb3875e12d165f57b37f876f0bc92e70cbc881ce50b6ec9b5274579d923774679540bd2aaccc19a2e8e6ca81a5caa83f2cc128b79a3cde742159b63633f823e7ac04c6d24fc44dcc5175a8b7469da00061514de9ef5f8abf00477d3381c8cb8074b04e55e18a3d5321cf8c2777693993836e51e6d67bb71b76447d0b1e47ff318edeb199eab69ffc7733623a272213bae3998d14d0ed2eeb4914856799d3f4e1b7b52f09accbfe4883e4e2011ce13c4072ab088e02cf70ad3601820517e284176a107ed3e049d86bd7305f60e5f6150146f8554b73d9649aac56b8029726363f79851cb186b20a3cf03e3e98c0b170b11b1ae99fa2e2e4998f15e3328c6cfb3b8d3e29b850204fd4156af76cc97c99f7fd542e63b01117af96673b73c61a5be0c13eef7791094243839f7f91aaa36352262e73164e198a432a93bc182d7ecd848e2dc4709f40d7fd95a416c83030652fec5af23a3464ba1a7b00a1300df5d463dd7ff49595b46f0aa274cfe7e439dc4a76e172502356c572e8afd5e3521e7f2a7f1c56452954d32e7505ad21d78f84c0aaa1988767c4c1e44f691a933c25c09273f11815e43a6456784ef728e74a2ee3298b0d15a81f6c59b1e04ac9649f0737167535fc78a9df28110f689142fca63e831b21434ad300f1a9c714b9805848bbd6b9ea53f6b40dfab3e3d47af76f7e0f558f6bbd1c441ea7774ccf73144b741226d8aede1b0ecf786231f8b0a6bea38e83751f4bf2a9abc746d6d81d4719065c44ef7236dafa70e549f79577d60c3006a86549f479617507b045f14e4c5e0de47afd47045bcdc46d9ccce4b28edbbd852a6eaf5c6bdca8aafccb8f935bf0676cd30a4a4fb40599138598479b5758e90f0c1c371fb6b91217ac4d7d397017800b5c6c7646f76f6c74fdc87bcec204a0523621dcc5ba49a2e346a1d85edea323e51cd1acfced4a5e453b53cdd654a3bf9d45cf84aefc42a9668445625bac318bbd3f179d86bfe907dd008c72dd49ae53e405977f3ff87ff10d0b7071ad8334c75e9e82fcdb3d4f2affd7ccebde193566a18cc0e47cde416f6f16660dd9b0dbe8a5d91f94d3f44de84b965a3d8c79f4315893ab22d264cd10223efa69bc0202ad4e41c6c92def874a9e612165bcbb468bee22d40779b40de8836239c1d3977dd94fdd367273d26aa42161a395e04e46d7bc94b50611042c95b1974f6252e20f1556e2a01d04540f896bd9965188c74cf73b2e9eb549691b1e5852dd3f6e7fab8f2a780ec7345668f0718dcd9f7c977c3a52b7185d94fe2205e479a8fade06624cfe899cbe088342a4c22f21febf268942f6a82ae0a48f525d6cef5d67d5b760ee91eaa3875025261dc38cd94f7920dedabb374041b48db59fe9f0bacc274244e13aad0cadb17e5152c589783d726ad684660a46e3e83b7a73f0d025b247f8a68463c061136b2711c5a211aa119efa13ddf88dff091ab598c61984b3c50f314475aafda66fa7a92ccdaca81fa8293d3e337966a668d882da0a9b65eee030d9c3532c34e538814427ee6480e0fad5e9700ccf4ad9b5f4c39979b4085665d26d155f94c350fa1954e36a9600a31dfce663eea1cbef1ed43124409f8e9922c107210f0ef694f5dc388982dba792136c74c6b953cd58c29a003d9c2b03c89272c65ebf654b4b76400c008eeb2e55e912be433da5aa901b9517ef7e4ac5c4807587a64ce9010a4fcfb906ba99581d11ad89f6e93fa851ebd4c13ac075205e90053131921f7616d2a79697d9d08777249019f54e5274fc59b09e508eb28c38aa7b9a861b644281721b6cbd71d8d6487b3a7ed999bb1844e02adbc05092f37308b13d1acfae5ff8c2274dc7ef6278eb8343946dd0c3a22f557839d2fd0d485cd9baba1a58e9a88d7cb3348ef0f74b4e90edfdf0f53fcbaaf0a266676ed463f98e243f2b373276e9cc14bdd19c5b3d61f81b44c76a0b9bd9da3b31b66339551ec4d7e137f7451a85a1b30f5a0c5ae546907cbd0c3cfcee278cae77af7375c4fb1824ae5904519f4546e95249b17a9a0584d8a7145bad8486a19cf2a62aa1eb13f59da48c1b42b1156d4f0942c0f261bda005556c823dc1c2d0bf251890bfed9f07b2d3a266eb1da5822a6802d9cc28106e8ccd7f87da2f731551d54d9a44f414e54aa80a1c6d9472ec81ad72cee49d84782db2d144e0dcf63f928159635ca3c51bbce819593a2f8c1c884468ced9922a82dd2fe9255a0e08faa6e7c4e5fed18a465033c5e2c11b92a7a7e4eee1adf75221c3b33a78b830d84b228212765419bbcd8f1738aad91e2b528a8a1c4336066477063613dec1021c4df17368d2af78112abd23f7d562231565e9b6dd03a3536a1322a1a6d22b7301b29515eb44fb23c4a0bccc5d1a236bc723c2b18db0f94e016aa319c6f09c5992dd3cb0d3d324b8f9180d68db013b7155a59221c5ff027b339575193a23518d5b4e0b1c9214908803e7e63d4b9f82d8d745d8ca3e5bbd8f6309c5e09916d5e8aa85bd1fa33f7e3f4344c811750d946f4e0753345598d19a1f12047ab1d548f8ae40bdd0964ba8bf6866632ac5138c5b1aa02af2f32fa8bbd91f891949455f21134314c5d2f3690b131ebca108b12a6c1f5b4235362d9d3e9f2347baa3b2a559964aa8eec68a1c02131886a87456ffbc7e770f5c587d6ea5a62b91670f582b94ee3a4d432edaf74792f73c19f5f2c06c598004d562af47832b518defc484152c10e5074c38465b27adb16f59b3512b350083f8c4fb1f79ed0f1865a3f6940c7cf41f68eafc1e9cb1e0a2283f7d601a8e50dee494b7c624c81a3718cf3e34a0962582d0dd5bd28bcdbae3634b653e57bba414bdc189def226405e014ab12b7802853a030bb127a90ba1f115dc9abda9c758070123ba8a482a7d370820ea407d092d1d17d0c7e3e961cc90ad6f31e12538678b75f532c324e94db85ab0381484b3e9b01998bf84fb31729b1421a47a6e7825b71108b4122ee8d53e4467279663481e049c42e8c8487df43086d7ea3cd9bb1ad9741d2eda0b03e784ecfa3979e9480db38b2efb703b2f59654e93c30494e25ac048052f2a551c3508ec7c6e524201b550816a0b64fa43b709e79214ac2396546ac617854e61d3bb7a99f094ac27c636742a6ec3a1d8a2f0baacdaf957fcd3c5a50473d4fe7ccb9ce98aefefb28f227d5d9c0954d58d18f44efbb439cacbff8495966645316d096ec46729c0ad0dd8358bc1b83e911fbde360a5fea589565d4a76aa30bc057119776ea8ea53a92fbd3aa80ca5a4f5aa6ca1282d5befe510d7141b54ed007c89b90282d7f993eb97fdf9623db6321f009bc1c2b2c8ad6c738e1b755b67cec6f813edd7ae67ac47a747e8209b1d86dd137ed6d455073fada74865dfac15abd214af499102a923b62e9ddb2236c143a494f2f2d378e5d263a71e1ff00d601434cd53d1ea49686786ed5cfe13b21a38fe3e3b563b73dcc38b1dbe8eee476afbeda3df43a7f16032e77b47565b4abf6b73ba6e9df64449a0847959d78fd22b523ad62ce3f70898ac4888ab8fed20a61084cc0253cb4edca41fbb5a693ebb4c304b472dfd6d0230dc124a728f5653ab2a65fefb384570a35e1cc9c90cf59e7d90c54d8220c3992c589a20d209f2e209c4edfb8009aa8954bf159c31cb40c290dfdf4c05526ed54d4439aa1d53a5839662b5ead7c681d5ace3e2b0685c595c4de6fb89bed59096c8f9d891775352e814568135cbf4b1961b7e52de6780a34caaa11a7bfa652aaa4171f6d3896ae41ba460e2027ca9813e94939a7dd579f3f6421e0c5a2936268aec3ca374d9c06bd1579cad1c4c082308477c07b312818f38b3eeb69cfddd3a0f454aeb40428d2c8f6c43e139da718ae8133dc6ddb2682485d9913690adf218cf21c397b935252b9882696180eaa96723ca80d7767fb37c1a0325ee77efcd5cab291773843f524fdfaa536166c607de4434c28f771db5f160f3f5006cc4e09f31cc5d0c6462d317fcde4fd07b529d6e66e5f154d81b22aa7e7cd411310d1be10ee6c35994d36ad4448f4558d56512da9aa54dceb60f439f8c0b7346db7c029425b2a48aa031cea2679baba916107b9a6bc4154018c378f2b95f26ee268922ae24ed507b55c679fa7ab82871b5d4019840b09a8a05c4ed4b7cfe46bfbec32f3d38543a27014eba382229a710663d368902939ab250a20581ffdf0bcbff5c815807a64799d8f16a653fbdd5bb7d5ef8eac61fbc63c10056a958b9ccb00a6ac627e39f407f3a6209f0b9dff977d70e9a4b0eef89d87415270a3f6da577a5a572e1eed5bf7eb9d2965334d2411ba299e6a45d0d0383289ddc3aaf4cc0053f6cd8b8a20098780cd96e540f7a8f837a39300ab6e36a4c6122615bd6e2c02937f607f4675f6c9807e5e12d1dfe925c5ec256f0c0cf78928d4c63ca440af62604accb11c20dbd9eec7d32df2b0b257653ca52e95683d047a308bab96a6413cff3545cce41b9b764feef350c20068c922e0dd3e4222fe4a47a6930b2a6a422fdcfefd6648c5a28249217df212ed4d798f505fb41d61fa9567de235f5339672f6016c3b650129e196f9c7763c65f8fd824d15d3a94b33cbfe506a33a514908ca6db5a5b4de81b72c4d039ef5e5d96faa3fdca63216f272d303838077eb665074d0b00dfffe831d4c99dde70b4c815c4787164cd1b185f23c8aa269c856bac9d7944b398697ff0f6f364b15d32074c1b7268ea187ab445a80013a7208163861fe420332434ae41246e37bc8479aeaa95c6a54bd9a81bcea61b7035aaa09e5e0285d9db3025963edbb27f1c1d45449d03f749b49a7a7aee4eaeb823e815ff572de5d34ed0d67a9a889491cd4db5e9897ad332df8f5a9ee587d4a8c43617d946e470df22caa71f7a5e2e6e0c0d930cbf6d7c28d9bc562d458d6b6bacefad60ba72e5674fd699bc6468aa556e1e74545f72a39896c406db3ae0aa96759aebb98860c02d54318931699125c9dd69a273250aed5ea71f7413e9fdac6248f60b83fa971624576ae9bc0e32ddbf1f269030325392f52a368d12e346428697dd2633a314423db57f3124208b1c2a4b08d282348f751a37bda145096616d76899c19eef6a6a6dbd39155c4ac0d5fb3e8c7a5afb6b449288a77f86fdb63c6c641a39da0dd89c5bff9144670a77262d7fd5a823017f56fc1fc288d6b8a9fddaaf87beef70c63dc17ae3d415fb5bfd3260fe349023f3bd499ba091c48c9b97e7215b6d4a5f26cbfca1a41a9eab6b594fbd79bc2ce6168332c2fecadff011057b91b204308042289a9f12a1a77e67b57a18b0733a0c9514a138d3f6e80c11312b7bae2a4efecc1a48190afb06e19a4392442dc7e6da64777eaad85e16efb9ce27e9e998a2f45647f0b6510dbb9b74437ddd0d41c6984b4eeebaff2fdea4dc5329a9971db2c0e01e58bf77f48b308fd7cc0a72e90c33104d80e0b07e1fca4f18afd3286f776f76c825d27e6ec1d353bf344b45999be2430dc9cea16f715cb6d5f442cfd0b98409bf708709d28e4a88219e862afd185b199264128830161defa27374ec35899e609d725f1b5bee6f28f0c5c88dd08c5120c75428161dfe352e46bfa0f32d839324f11f421b4e244980d7580a21787375ec42fd87cbbfa1ccc463f7b674f78bc8a9f7f0371a5c8c8ce80bf47e8be0c8dc5b9b04a1d878807a43dd27d1d1380a860ca12c7d663d94a128b8532b10088ea896c2b907018dd8a84cba2f7f49f916208266b8dbb60774354254833e57e383bf52ff54378163b393cdfe72ad0498435cb6217983dee0184ea311fe77d061277709edb09116b9a5a3f17d03fd49daa550c395426b0582b9c1f14f364216e5923dea51b87d04209e4af54346b46b2f5bbcde50004e375369f08c4cdb8dec436f529fad7f1423a33459eda90d70c3871d0839790a65a6381f4995d21cbe47a9acf793bdb5898f523c6f33a6c20c8e180026061e12104e0b8c28d9f189da1e0883bc0e0baa9ccf581b078583abe09cc30872a800b9de9d80d59af167dc50326fc29e55edec40a58b449e91374cdc1d2f5b7cb40c17f3abd6408eb38bf9deb5bb12f6e6dacdbd7b12d8a89c6e6992ca48cba1af969d32a4e2a430e561d6230d6a8ff748b5300374e7534dfcdd476d50eb4cc4c032c57ddfbe6ffc7805406c3daa07339a45df537152179617dfead2fbb30f4d79678a2c9b76a5de4866be23e04e2b89291f614525c174e5100682f8e31f43d058d9be004af3bbfeb9193dcec7d05b52754ee89b8f62b22aaab298f412dfc497af64157bd257b2ed69cd6f39bcc2ef55395da3b0f30577dc2132c7091089425e3fa0eb97963d69782977d930105dd2b291e633e1f8c50c13eb5ff73663bf5792793903bd8b85cf34216d100f30489412234ec818e636e214efb57a59c739453362491f404e04a363d88b632ce5813976eff8c5762abbd4a1016058bad2f6a90d4abf1e65d348a35e0dc1b5168fd53558fbaa25fc5d129c2fb9c5aefd0966980122a8e7afb08331d9a234f0df18010bb9ac44fb535b1cb225a2404667fc833cfbd69ab4fbd307711f59e231f6f525f12e6f3e3a9adc96507e084d8da0f9e46ca91e54343f456b12d09f7cf4d89186bdf127e27fdc3b0d8ebdbffc49bf8d344c5b2b2ae51b5e477f4992eb96a97f6b2d33df900298e1c5761dbab7a274cb69ee36cc405fa3ea02d0c17a0aec01f1846a19aef887f66538213e65625080a2f248003d691e62c675aa3c97de08d06824988aa06a42b946909866d38f52f437a046a404c988ff0328f3a0408753228dc21b68b6db6b889c92c00b41f6139511cf95839d46999551952ead152212b8f4b1d25f97718a36ae2bdc00931e0b218eb623763bf280f17a4223d08a9e3fe836be7611f6e7174af31e4ffe0148e05fa4e8eb6563aac975ffe287f87f36ce3bfacddca804c12dcdee324fb65337b382e964f66f27849b8e103e6a5306bb8be7be535d902b686b1565094d20f709d8d97135d2dbbe8309c65ffe0ae2edbf0e835663fc4bf0b055073371f8976395ae7cc20e2552c915ede53103808991f8596c07ecd117a5c9994f91cebe832d21d628b1bf4b0edcc9f27ebf713fc0296ce6eee9220921acf98786d446f9887502c5b9c0f4ab02c0cb1bc4c29a78f669245d9a3928c27adda9c17a8537340fb2403b3f005b87b0fab70ad0f67ed8318b9aa28e8c585e89a4e213c138917c5ad5f219605a6c766e971f5bc25c709ea432b497a61ed72a24695be447ed70506b800044133b78afef4f941ae06f7dc04a060263cf4965e58c8679aa9e6ff1865a9cc8941bdbffdfe07fad4236859ef7f7fb4c2ee0c10ff3c0ebf299a9fc70361d8e8829e8a75b0117981daebc2e176b57fa8e5598a8a288df29a292309119b7808a645c92dd3921c2a2b7f5e5db137d0498aab82660e5cb947ded0cc7e9e8b8609bd66e5a0d3e043f31674800b400ad2296efe3c6d05ce03c03a24d4610caec224b1613089f2fa5189d92ca38731ab22b6325da7e5f7bb9b5edf98349bb0abe3015519165f492cf169208f842da8e608e19cc7289b1e6616cfa0a27b2659ddf7e4e4c28a5d89efc0657fb5a193b40b93b1c411269278f18fca2dbab510860837bdffafb116673a2a1f1175c1738ff6627ff98e3690e0a4f67a10ab0d1ae2dc6588542baacc026762899eedae2c3855f4270057e161a3aad3497a3a440e461b8da4e800d5fa4339da554f451068f8cca978b7ab963cb9a88d1375c02de8d3a92f19079808c1604fe7eeb9613737d289fb1d2a71c1606e381fddeccd55b7b2e5fd7ac1beb9fb8accd50ed45f9e0ba512a93cfb445e5b6466afed4e0cf8db09871dfccee727dacdb29e731c88fab671c7279dc59bfc353d505aa3ea8cf255d48413f9ca4fe78964fccdb5e2591a4bd0579f8077476f30bf7c34350bd7898561e7b28f7f16ef1547cf5ca470131797734a775b3593a6dba9b2f30a1d71f64d1843e047468391fcff9dabc70929f616969ee7f199cc75962fb98db8adb68ace5348acac09f197b9d055f06d4c11cfa80508dc07fc889cb7caaf20521b3fd2d6813058001f4c5ee0e44404824b66ddae09e2ea783c28d856dc8b382777c6ab71a9a02f9a1f621f05dcf4116f876b8f08abc41bd8f4cdbe578de2f7194bd09ffc3498e679e6be0065e9b6a5292399a19eca969e41e470b0c5d70869e65f8350eb914733182fface0a76613b692710e87a5c8ef255139c4893bbef9c3d3c0f01274089caec78f400fb3b233a4a4cf3f726dbeb6bd072ea7bd08f2f3cfed78a4edf5546ce55144698ed206035053efa55974bf59afb599ecbe3cdd229c22e03108b03a980b0108d3d31c883576b5afaa473abc9dc097d0b9790eeedf72527f11b92c7408120c43854a1f290a8e1f04869973b7f1c2da454a0f7543aed97fdf7ecd85a3c9a4b6addd0cb300a3e97bd833d03a15087c7284888137f4aab32d90800045dfbc190db48d0344523ccc17c7ea2ed572afc644d47322e81d3326105d572451542bc0da44cd3dcb4473174bcefa620028827684125b1beb079440c9c497126c96f275876efbfe07334667c7c7a37683a7cff23871503fd90e51723780d9a2d89b82fe58d5aed9aaca1221246fe2531b96a8c674c5841435eacd143c08b276508d50560080cec3c2b2ad9583fc1513bcdad9b7ecffa636509f9d27cf69384d84a6ab5015b0d8c8b899ec82d6f5b31f0a9b3ae6a44ba16828a09ab48b4b06dc0c22cf3f8d196d6e98ecebd0df048613da05a127e1dc6828f38af446e4c6e9d8d8e334648faa64c0b37d3f4cfc0667806f1c137f28f03a5c8d1e22c1d22c3d9a0c243582d3465504a21736d2b4f2a0ae082aa981d65dec47cdc101e6b2c6a3e1088a3417e6e570820d3e3686d46a08ea7a8a9b4cc386877b23dcb15188eca5759150cef263d309de97ea57768c256f0511920327bdf7c4096fffcef07dbfaa0cc71a83343b5f9b76d722bc7b462578e3549f246b0569312f2e1602f415a4de23e4369f205680afbff1449946c445ac9cb768b4792858ac88da338fc6e202b84f2b7115dbd73a6448889c851e0890f09993df88bce5961f660755c5f03927d4f7d6838f1d6b3a69f9de8849ce4d7983f672996bc05796a21ae9fad188843886e58ac00467f5a7bd9d0c33e3c9cdbf6ba91df4f85c04efb51f3f14e0cfccbdf34e714019ce634632d990173a710668af88709750ac2efcbbaccce13f781f60e2e678214f6cd4ed4dbcfd6f52263ff6916553bf47c16082895ffd7790c3b670f67cb086c80dabd83a94c490423a2195d376d6fa0b2ae58b0ed0309e0b921e2b3b86a0bb8c284692ff57511bc25855effdc7a0ffbf095392580ee309092c88b84343ed7ba0c005746cd1fdf2b9d05911d4bc2fb8b10e76bfafd5d457651a0214680cf7735bb9c1cfbf83d8152ccc44bcebccaf6c55ab06fe07b522aab6e0cbb619e6fc2672b6c2d0ef2eb83b6acc302fb4d734f643ea19b47c67e02547225995c18c39bd6cc51ac11d0e87a686f23999c940a9b223950526015fc5acaa182f6bfcb53acded13e5124060e9e330fe396d31e9cfe4482f607f5e9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"414a6f51bebf16788608c4a5ab2bffa2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
