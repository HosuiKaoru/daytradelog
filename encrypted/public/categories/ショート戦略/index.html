<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"56ddc1fc60c7cd969e8128a1b8fa70b4b6f7cecb049765085c95de738e67b9db8efa6268527a58df7195a61457b22f762e0cf66f95c0c8f4077fc12b8eb9dfa4fdf0fe70fdc7b5a079b75c2e1101389c77359230acf45f12f159eb8fcecdb40df57e6a8a0624eafef998576b6818efaeb94b2d93863bf927f456c738731304cdc725bd00fedaf91eafe9fbc62ffc9cc5c33e9cc53ab1a5a3758ebfbc9b99b0e9edc1b6ee076bcc1fcb60a1e2f782bf611cf1858b8231643dbbf8099245526ce33b0c2262e6307b1658da51af18270b999c1fbbe125dca07dc437f0f73016cfeb11b3371c6a6c1838da67298adf7cb7f35f5fcd5538c809382971168b2ef6685c0e428e18bca5531b15272d2948cbbd013d427dee52824f9978a1fc998feda4598f2476dd01bc93d22183ec21f7390f309ddf1952767d304ebb7d5ef7ecbdaf457dbde4e733748660deb405b41729560dd21a2bb2ea72e831909fdd920f7420dc6f0be98595b1fbe72c52a65b19ebb9a85537e38e6c81e8dc2d99e202e3ef42aabdcad6a884f082e3355a44d2d8986c6d9be6c4033c501878ca337df904c221900ee9934377c9948badf7db23aad6a2aaa6903a4dcc994e8d6b65e6efc76fa20a15eb74c3460b2a535569f933c88c9f7588b1e198e90e6f490d25a6641ef5a9dff19281fe1b7b5be0b243f5f25ebd6566e1f973791c9e01906032e7b272731d9258fce16e3d8531f5d7bcf633ac845b3b2641567dcf5dbfa7ec1b68ea5201afae26a177a6e0b0cf035f9e45a77bfd4157b91ea87ad245124d23875b6ba472114dc3953e804403fc3ef3cacb6343ee48bc0f2ada547659026852e40f488596fbb4c2d18b610ad1e0c3d89c90c0e3c2b1fd6914f56c2a05ae757ce461329d958c3dac7d47c5d551f66bd165dab2603931a050f7160cbf8aab279d962274c2055d5e6367a8eb79a7bf03d4a2e2e57d0564b9f25435f72aa76ab09cea9eb4caaee41bba82024d1c479cbf7010e3632d6822f74dfa06df8f0be6401f6274b090a9cc3257af67edba30d0b3bf6c5f5dc74face4fa20126d1aa363fa6d30d309266f3bc070fb47cc9f7a27e50cc9e5f70f4291f17ab0882a6fa4b7e0346d796acde615617153072b6bb1be1ed7e2db602477849132f36008f33f5a30d554b05bebe0263c07fcf47d7e1ca2d6db05de17cd22c1204d6e2bc21e1a39c9e7ac4f2f3fdea82180dc570f0b2c08df3dafb9fdcf7813e3a02bd360567a8b134c45238cda40702c3560fe68a9500bc07832d51bdd279a9b1995d94a77eaebcf5c169932bc03b1165574f6f9ee361dbf875022dfce90a87207f23cd11abd7a18e3ea6cad72f1d77ed4c70253c437f023154a5d1c69930211477bb779327389092671f15e934faef3c6b4963cb67c25ee7733584334bdc92073a590fa21cc859782bcdea64442c5d432a90143ca43854a71ac4da5811ece825cb18fafaca4707e25adf0c3bfecc962aa2ed1f3b6fff06f191be492f614879085c9bed4b7da1a105bf2d98ec42b6468935eb9e3d0b900938734a175454eba43dec723b4644db83c7eaa2a00b6c82a597871cab18531eda68fb9d45c9ccca489a25c010ae7ddaa319eb92e51d6782e13ce2ae609ddfd9c1b627cff401b747e9eb4061823cdb6f105b3bd04ce3ab323816b3e92ff530f2f54e23c3e1094eac51c05db27dd9860962b511e57fd683370b74ee77cc42a3ae7d7345abf06d8ff5c5e4fd9b42e7ac4a96afea1cbb98d4be80fb2a796231b04239bf3e861c168eb2e716021451394f53867db66e46d5ba5d1153b0c1b2a1b4ff71ed282de8df99275d7e2c24467e44b3e3c87078ac9340307d006cf96809ec5c2a4f34880e299d5c481161852a97ef3e0149e18a3bef1fee50b6984e3e6845da711826ebc9e63cf10aa809bc9bc4e0ffc20c9a7ad4b5fddd1995d8e1f29a7676d4701624a411fe19c61c7ea8971f1300b323345ce9e38b16459a6b6eefb0deeb7e3543748ebd554d3c9d0fcf71f2a885ca5f15dc99de4ffffd8c8ee8a601b9cd009ef97ada23c8d05b28ed8412a9241798274e45035c79facf1ef208e5c8dbeeac69b337e24e5c89faff1f44ac062a080fae21e8294da869616479786256145ff4a30aa14ff57ea06d177092aec5d721fc345840ffbbc57116447eb734ca5c61a5b5c1250c3d747e33885fd0810ee7139914dc6d3ba07242684ca07e6b7137b4e55f0dde862a61685edf3fb757dd4168d33f71127a98757b0ab4a4a88fc89462fef4dda79dd2173fdcfd479280605807d85adb6cac2f2963938d75ddccb020a06af118ac05155cca8598912046422384cc5a67c34323bb392cb584b49ba0d982ea2906952c7d4e384f2bfcd6b639ef41fb9cec94eb276abdb78c66c230da681fe7830ef3d6ec602a5d899d93df4980b6369b5cb6454c1bb7b0f70e76411e44f44f4301fdbc323bf413399f3e38d5dcddafb3295e2b8025fd74d989f451bed9a5ea81543796ce8d5b4f25f359febc727254cac113c11da519bb6896599ca7bb38505ae00699952b2af20882ed66149f6d1a36551c4047a0e1de719dc1fcc7ffbb174607903edf3e316033eb104b381fe60ef4a9cc8555f1d3450b2aa1be8ef6c5f26cf8b96db025abff5b9399f5de1dd77f31b48f1d0a82bbfa8d03d1ab2f36b2c57f84db0ada8e2ffad66f53ef092de0c892e8ec854a9aa851723b8ad6aa62e2999e4bafa3d54d3a3716aeed301febfc0bb676d207031dce8c6c3089ce1a87b8bb5b0f1bfd15d7f01259ddf9416cf9f215b57452b10dfac5a9a1e21de545dc3d32cbf923f6494200d517d464d71cbc83a7967814cca75b2960aa68fcfdf73b1c59d6f3bc7ad0b3dcfd85091e57ce9faf18f8a8dc0d1216cf42a142b5bae5973b7b6c30ee3ba0e59754af0713f0317e834ca05116ae5fdbd07d1537961d3f1efa025794d5449c990eb164995c4f422634a3720e888d59ff01687a40cbb04166038ff64f8eb3da456c7511489de4157ec3fad289da345a1bc96c521b0d07fbbe911a514525ac8b8136ba95dc6b1a11da67fdbd4b620964116d3111beb8529321b3969d2d190b887cf233e7bcfbb0720b8a51a94041b3a7749612b13054ff80a10d4b79034f9a62b7fcbcf13187349be4ef753d2645ab31afc8cc4e086e893cbf3df5bb6a08b2c1c7ff8285629a51a4135c4e89f2532b751c660c982ac704b1cce913369c85839c255ac262aefc211ed8dd2b97263e67ba72f1323f4a3ee4d470cc460ac711f880bb017b05de8e91bf3865e643f7f726c198d1d819095f0a59c1b643dd2c4f2afae7911d5a653394850da441f2686c53aedbf2d5e6e3b00894e1176cb8655e0ae9b28e31022e11c05fadc9354953b76a304d9795afacc907b1c33b840abffd5b44faafdc129c5b26540da02df6cecebe61c42ad4c65b65c225438eb996aac73e32d53a3283e31e297f480137eafc6515b4eeef1a267867085c304337f4c302da471da4920d66123489b398fddd99aa918b8136c811dd804c55a85feba9e388c2cafb27753d44a05644cdb0d666a128e5cb822ace71f82a63b924a7bdeb5bc5e0bf87fdd0ff885ee5a94fb695a59d1fd88a981a4897fa5ec3bce30f3e0575c67b777ff7f7b25f2ec76e454e652652a8a07b634b6c9c2ee3c448adad147649a5caa40ec6788edcaca8c187e3bff283b370532780b5681f5b47826543821908fadc39d886473cf2518c26fcbd6fa2b988427ca7d5dfbec8ff7c2764922a251fde3287dfa191dd4aecc01d5de91cd7bd71502e59907587f9bf538a95cda99563a1362c1459c119c061f004d718e5e19399e802f9a86961f708fe36194c1d990b23471b50e39be2b76a5fd548e3877c1577fae7c8fed26408617411e3c9bd3ac0a5aa98aec086fa16abf17b585a00e98fa7760fefeb0f9a7bc5222b4fa3230baec327cef99463f809f29d991b6b654d0501c12ef999ec140ba3bed213745da9ff50faeb64d33f4d8bdbf755c87d76fdf308fdccfd1fbd49cb577e9bf7df828b83a0459386e33df9a9a4cc1e5d5ac3b8bd3066ec4aa1e22b6ce7de837fa5e6371fc4da695a0ef3f6117e7420dc70929010f8518146f4217b892e6e3a45c5870d56f4b6c567876e67d9a5a44a84731fbc5345c3ee1e5f6d962bcbbb5468084d434c8e4417147d763ee917ab287bb4c3e6f5cd3953bedf614354dea7a0ef2ad726bb466716f548907953b3c9a7cf19a0179bed66b7fb46539589445ddefba902a22f8073e9cd78fe9d7dd84e93da1a4e5bf97bece5e307441f66bd2d3f9a3e2b69d7020d724a296f08ede8e844d6dd48eea8c828a080cf40008a5338d2083b556bb6b6fbda3a8ce0b9314e78c18af5c64293a8142c8693a3817c2f45feb467c64631f7f2fb2469d92b6d3e9a506d614cdce5762ae708253281fb67032f3d5653c35555b69b85ada4e6b76875a3bcc5cad654dab24ae81a92c8de63f6a77e80592753172f84edb19786b4150c1d373802b4699c191133013ec961698c373d8a622c138f36e8875f4595299d04efdd4728889408330be93c1ad57e7d3300a8296c83dac648ed88b735a96d81a0cd465e86ad59cb746536a1f2ef8f581b09c1a092b65ad3c848c9664e80db73f07db3b810c5297596815f50303c5b1103a9cf3d10be231a9a669977415a99196a65fbb469c4f1f0bb3f7b606677bfe44800821e0a8b4b68c4bb3ccb6c6dd92e2025da4f8321cef0b3a4ffddb90cecc8abf2d353e224a9ede0bf4f78ba4090f41569415c120833f5d1437e47c04d060e8e84f94549d3a9c029e4381350a613b8577625ba156e0648109d892ef9e643673291e61239614a6c4978c85a2378eb0386307ad5999411be0ad2f57e9003cc481107b021ba5d8a074b0a11415e6177aec202e0850fe7a2e9641ec204b5ce023b15efa9be4ef0da7a3216db826cad33676d46d6a4ec26af8891505d7bcf6f153981ff7de0d2c7eb2e9a2cd0ad843c0cb7bec8e0c9901d808d2515b72fdf6082023245b69b7b48e590bacd3cd43ba498a76b9f61cce0ac247c515deb59ca528cc448fb1b0bfe301d7c83f68a39c7eaf3ec9660ab5fe747c719f154396088170c855d9ce657677381fcaaf99d48a028659568a9c37570e335b202eb2f63c241712d4e623015c77539d77569ecc9ff5f85fcbf75ae7848a3fe90a982622059b9fd078803b242c4627c618f818f6e0352eb58c508ee933d8989c38d761482cc7d5f1a2d4384d24dcf057e8c5b7cdaac89fb6b3f058445bb27b643ee4e70c3fd0b022e3f9b34f0cc47553263e934f8956445eca241a2c75f2e3d01cfa60f20bae0ad6e7dfc403ab993f4b62f160be4979e0bc6701c08d7485ee9546537695bdc2a51f96937be0c9b9198a03e80502f5fd5ae41d8a8727912e0503bede624c08d2cc950529f78f5d10ad141b04f9d0bdefbbf000343695ad7b669e4f08b858f3c8c74ffba23291e153b566161aa67640f0ba85028d4fa554ea45fd37297449b8c92e411070913473989612d1e6fa2cd1f52f3563d3d63b78ef05e0f06c84ca8762aca716cb041fe67b3074ec9dda14f9cebfff4ba36e7c5e9c46a5e5cc30a0ebf943e4c6a54dc75bf8246acd968a46c09bc43f8332691324d05fb39441c635403dab9e391ced669590917457af0850addaa1c44430922e6ed1f6cdc6b6651866a319b0bf37d2a00e202ef1086a16c0d8183072b8265c96e0d7847000bc53b94d00006edf4e09849e6038c4332b1adde20b4bbb83817351b3f69a07023cc0516a97d0c8e7e55ec26fa4cf08b92b7de163cd09e769ac3dd18169a41fd79bdfdd197db086fbc6b0e1a59c95a11601d303056242a345848b459076bbb1d18e45c14d8fd6ac618d890401f5c2ad207a4f8ca83e5250949279b205160704b22605b3353630bc57520a46d0a55ddb08a12c037ddbebdd7e61c557af872cadbc464092315eec29eaec9f25578e00e5296134b85fc7444ad104a5cda8722b73ca7419a4a44870b3c7a7fce59ef144c91fe202e533a16f3e070c1f6491f5c1d1593dedd381f3a66e7a7d057fae49b6b4a220f104c20254d32b9591f81547dcc73bfa8bf5c866f77fd9723b0df1047d3a436472881e8791ad3b6b1d9f1d09fabac44e53609ce77fa389b5fbbce347a1b3ef51bdf8e1e0e775587c4fc7d7229fd6d44f67db8893be1337c61b99ae50ccdbe99b05969d02a1b9b920aacef5a7be131e7373f295ce77611642afb86b3ef79594a902d53cb75018fa20edf725ba22017598498bf7bd014bd9c204c1070e1a3dc93c842f391792397d18e37f1ab0ea5df0a95cf7421a50393a6dc5e6dc22fca8112fb88d45e520b2d5e97c8cd6b4ec87bc746be7610c245279496b6bb820545e76e7e1ee413d61e4d31d77823ee7c2e52818dc32c2b2342186e9f3ad6669de3fe33f683d45506473be9338d2b2caee7c73d2d76d7ae9e5d79321df3153e44b0843353d22357172445c551df9ccf94435228a02cb47e87a41b036c6be801b74ff77a1446024523950e017e5aaf27953d0b373bc05995bbbf4714a13f9857d10bac5b57ec31b3601d456671595c2cdd11dda7a03bfdecb7e851ba8868a7c7a7de2e0f5827c40b3fc408d056357d117831d31935479d8ff3b1fa5795791e57ff921f17447dec8aab3e9c9fff4d2285b6b5493ea377038a3f9e696843bc029addd77cd7aaceb88d69b7cf0d7ecc44c7f5f2429b70461181d7009dc63c14430d586acba8f143380f260b7ba99b0d8b7da4b82a4c224c12107d26f1191e621bd28d13c0fcaf625d9cd6a92c06efac6298fff1d17e19cb48fa1dfbc94a053f035bd85a24de5bd54f21a55691e2490d4d869f2b2b7aec4ad16e3c30dd4ec51c8a002e9264ccaadc99bffb602ebb69944fb94526683387eed3a7ddea312e2bb00d075070f6e1d444d17a390acb97ac7193ec5edba9aa2472e8f7582c85b04cd117300fada1f05b162892e639d2449fed2be5a509a0d93029ca8d6690c71f7c5741e977ba65c7d7e4dd130f83a6df080e38babad8d863b6a851f9293938bdc0bef4e1fd7d80911446c4a86e39f39a53c3579515a23c313d4f3a0a4e50318d657cdd49077751e83e9a132ffc083feac5f41e447d213f62bf29194c0ce60c61da894e516b566a5ed682db92f768347babbdf06024f0072016e792a69a00d18832c0429196c8845d602278cf1c5c97c62fb943b56725b71c691731496fe8fe2d72ff6d7986924962f7976f449073666c4e307f0fe1962a8c4526286d9bf1e3b79e903bf6110783dc6327546cdf0d5f4ef74daf795c75c74d07a0e2c210caa4e5c710a5b39c6c7d74963b20e7554257a1d686dbd61aab1948d66b3807bc487724d58e662c6f3b1d9cd6e597694b9946cb281cf22064e43542ba5ec4efb4e256af0cda0f0b2d3eb78bbbaefaf68235a19191dd19483a39ec9955725dd7f69436971a76932c26a7d2f9e908d4170ce10516d8f5ef5fcb4441019cdee88c0cfe5f93590362bed00b12bcc31be235dc683671c7146182411fffa3bfd1ad06f7355637d11f84cd2259a5a45941c1e444bc7e2359922b06d834e4eb84a7108957173d5f58020ea933160afbce6d7be6cb4f5ee70f0dec5639b7fdf26d81026ef30460a3f7edd2cab379c796d70b6c79f19d6addcdf6a1bc24f153b95de3fa4bf6486ed9187865ce874c2412dd30a92db0df7bc15eea2937259730fb965937cc0866c00e63a2529a083ebf87bd580a078c8adb67926cc41866fca3383d09fcb130844c9bf50ab1d900d8e0a88c47958a7eaba68ed141278bfc016961a592760ad4a3eae2fda0df4559ebf841fd00707c99b146702f59fca5a5fe4a472d49928222ecc207e3bf150b0c6b6810a2ed618b3bde51530ef924d9850e8082e47a2f298bfe3a26d3ddfd1da0b4e9724b5682dcc095f1e1c81e4c9254fb2cca27251c9254ee32d556f30d6a9d5dc280f1ccd34ab2a2a528c1866c7a81a215643ff1b84cc6172a7ffac985ce3189a79c06e1514bee583a1f5ef116219bfb1ac5235a1d7eaa3089d6a7ff5cfc84f8e2b962e47361937713bde37ca65f145403bd7afabe46bfa82ce187334043eb12d912d42897ec7b14b315c9e05dad382d62f4cba2151cae0e0798acfc2bf84c19f990f25e4ad720c7ddf4cbc44ef8150638e02ea9d11aae631fa67ebdbfc72ccc8bc6f17c19ed508a11508f31d91ec5a7706c985dde083507a2d334e6a66a82ef8265d79036d34f949b50c4593dd0cc795ef9589b063caba6a77844e8f9b422b0d1a95aa0ba3c6f515555d858aefba96063cb143f6573dc865f65e4a0b3609a2394ef74803778c1a0e93ff741e51ec43159efa5776d58e56c2c6ca5148ca34d8752458d54f9e2eb62e3338608fe658617903fbe8d8d7e686fa781264f8a6eb1ab94e5b5b6aa0afb6fdead196debd17873c7d3a004139e7fca4388946f6f38ff8cb55eec181f2dfee833e9a62d7462ffaa0454e89cd0cad64939a7bcdc35c9610a36f044b60df74fbab706b1a7d2314870e0a65311cfedcc3c4c2386a7d6c930bf6efc8a2bdee0fdab5869379d9c78d9d1faab1754622f1b875174d54e9ce7d1a6a87c0df8d48de20a9892b7539354d11eb0646b5b40ad5c9c0610e4dae34a446d366ff5573043e0a96b49e0036a4ddcd350c346f042a0c4ea2de054ff0e9f477ca3d0198962706c5c8d3faef057a55eb8438ec58f4af093d84e980fe94086b8dd41823ed0a79a323187e05498fc4e8fb06abad608fe869fc4f86c2313d9dcf57049008013220b8acf448fe5da7114eec28ee4fc3112f9e74c78fc5a7f355381df6ac2e80df57f2e978f65e9d1d93b712c026b1e8a21d268aa52d3b71387fd8c8ee458913c913e108b825d15f02a06c7769d9257d6fc00cde29ccf8b3435cf1be9ffabdea7e1cf86d83eb09f33e9482e71bc1ae506b7ad3b367dfcc7ae137f6b4074742d914c8dfac2326f9f5594f5619c2c8325be26b9ba04f648e066334d9f81ade1bf9f8d514d0d2eaba84195961ef80c16f6248a5fcefc0ea5c2050f59c314a733baa875707f78678d69418b0d221f8b9b6661a9ffcb960e0e21c0d05a5192fe85dfd6b161cb7a874d911f950237bb3bb7d7a22d420b1f9cfd8dc2c1af549c4b2c60f961d86982217e911da796fe9e343b31e5492df47c0365fba4d87ca11afb7ee259c88c7c8842cf3f7fbabe0a9079aac2dd0d356b8441c8862a98bfd4c90e99d7178ace48d492fb6215b1c6a6baabe301678d54f8888949111d0ca0a61256505928a8ff4c540fe9a5afc9f88f6e07dbf565093efb1bf0865ec0fb440fead6410cfda89449ea2d3c46f00a4f033b0830801601b0c0b3927a33c0e8f1b76151b96c1372c702140ee0ddde0a3a9ae83d05c570014f7a5007f1cad218f0fed79d7a4bce48776e5ba513ad6c9c1f2e601637ee86169088f74284e68441105deb6dea597a92c4475a4b3e5eba6d433c3818bb037d1bf9e8961804a53f77a6e4917ca414bd4169455a8aed42ddb07708f6dbf47b0c89ef9808098f20a2a71281b576a14b87a59f9c3e57243e085be420efb1d74ba360bc086dfd03f266d9ac63c098a72f9b601d04580b5c884aa17e4ac3d2ec870813c2ac57acd2841870d7cee169fbadb7900e59de67ec4d1e260f6cd827378f03ed15ed1cfb403c27c814856a368f2c9f898a08aebb22b56ac3d65990cc163af0f99507e151a4a1deb5facb0b8a92cb8c136d3c4fd841231aa9199ada0cba23523f4c78aa9eb96a8d8711bfa87269532620b1b899f2fd4404c1151bf62974500d588577caa7129867a855337a22efdd7f913065f67bd3b08e37347fbef958edef1e3d6a0891e4d8c52041792378c1bf18b906f0bb29c1bd2a873ffa476178e4cc9d55c0efeee8326161aaef2f3c42ab0287b7d38de90c96b3d008f28fd83992cd75221e3db3d38ede53f5befdd6a9cf4ab4d7f0052e25d89170a49ef6c121e591c0efdd523439efa5dff0911233e45f7acdb9568f0b15e2ebe3cc9a6940b17c2ae04f4f4b5960f4a1d5022ca31c617cc59781db23881e4c49c5196eb5f633059e6f13b602c2fde7bd7d7b2acdf12cc7a0b8004198840ba35e707e605de08bd6a3a64c18e4326f8f9f99df97bfb43d0bb1ce4b0875f659d4f0a76619fba8793af194af57b278b2cc875c2153ac93f96ea2631e2915404dc6801e914c6dda3ea9703264ac40bba8472180f0ac155f11a8afa6211d8bb0d388822ab4247d06542e6dca199d59cd4a3adeba9d76aa212b7d9be03bea8b18864a62a07c7931e94e09655089f831480f857b19dec4dfa446a7c6283177d55ebc9d9909d0019c152a320ccacc3f3b2efe737082df1543b330ae41ccd6de7aea29cf02bb196c2ffc7bd1b7bbe8fdaa17c07e2414178c60ef6e162990cc19b3dfdcda853a6f63c0d5af88ed6bf5b688f4107e01476b745178757b519cfa75fbd1abfa30c7946640e67d7730388ae107470758a1c48ae01af6ba006397ca8725ee81e51a2179aba435b313f5f10b203014ef7e0d830993b8009b9294c04510d9fafacfc5cdd51d2333a3fc35e08b6ac203b50651e08e3233f3234bdf8ff3e92d01778d41598c183338c172210fbb4244abac16dbd008c34e3d04da647a2a7c4156e4b4aa67bfdcf5dbc2633effbf0ea61010da6f8168e772a8734b6c7d9016c8ed91ccf10efbaf885cabeba1a700b891b9868f8da15adf36f3510e9ddee45be051a302befdbc67e519beedcef290e497deaacccee454b9b8593554b2f89e92abca208f68e6a31f66af03cb93311e47b20f55b1605fc463304bffeba340e78983ea240ab14161e9ebe7aff660027196659e302dce0a46cb1d576a24b98e90b5c577bf7284fdcc48d17a18891d4bf37ee48ce7b6b7fdb20345588bbb349d44a783c715fccf848bc86b0e5b0d59837cdcb1fcaff575939f11b9094875ca5748176f1677784e937b6d3dd96903cf011a40c2952a412fccf07fcd5658e2b0d21379ec8ab35ba7c321ea33b6f209c33d7a43d046dbfcab5436d4b81a300a1e8740745c27cfe9ef90bc98575495e314ab66a559bb385919dc612c323412ba3ddbf157a09a46d3a6e36268d5e60e962a57481dd515462e79ba6a42e9a2caa1967a5b6f2d67e5ca6af1a7fb332d479f456b9431e95f51da0b01ec0c0e863434308ba9ca7c2520d24f676bd530929dee469f9b27b23f1ba5ecf6b577f297da9aaa2f3b60037e1286d0b09ceb08913ca0f0870fee325514c416fc3e7cb86b465b4a4399ba1e8e79e33cd049bdb078bcfcbc15f5967d339ac5bb926c6b0767cfcdb4aa2def5c0522f4a43afd63c66e8b06290598188e7123dc02d346fed691c0c0d13b615c3badea568c9440b5965380a63017925ad69a4b74116c6a3a90438c058114c36f0954ff080792eb6a1af298b84f99d1332dc8182e5d3bdc4fe49c58a1265d7995d3977609a222477f951abc65fee0ebf6561774d7df5106b8a6943278cff6577abe91d5dc49402d5d0aa9dcd5de52df7c9c193b13697100c5db40e1db5441b4adf74944d0fea1c4ec4225285143f676f082cd827771844250fd1912b7e1770c1e34a5fca391ddd7a95d93144943efb2834465267d0aed34eef2175c166b69cb290be8aefbbde7b16320cf3240081dd2c4f20982d9b27b640b4fb41ac42633cfb0f87bcbab77ff0ba28f949d0be1eb899b90693938dda7f74e69ef3286c7d0b8521ee9a3e9ab8e9982e8523d79514738f0ae01910a0a235fdeb9ce4e132a6da4d6fb5ab70c2c18d21f6701dd06acd7e1c39f423c00a2df7ed2fbdf62178bbc7810bbe569bf4c5ea4485540a18d519e4956413fc506a27de74acd457ad23690ac914729c9493f62e10b637749afa69c395a93a00ce69c8d3c078f5d336ec436aa23bcde211ada6eab84363cc14e7e8b9d4ddc5b8a4da44d1de0940116ef150bbbd2197907c1b8c6976bed373e9b0121c1170e707f9a399c2d876dce23ae6b070fdc2c5838a966260a8432a65d2cbc3fb309ea5e2d6beaa98d31d89dd70eb4628d68263abc7f5683436a762f76fad917b3b21edfc48cb3e491eea55b34f2f7593c223bc6651600206f57c0c5d18399f3cba27937e5af9020436598d3ff81b40246d76c3a86cf75bebabca10672004476eadb61efcd56e4af6895351381aafd5f350a217ff38d4ca662cf353b6d636edfbcce60de02812ed5af87b878bd21f7083faf0c7580888cea18ed6a743c5bfde36f0282d0301a504986aafe143c3422c7faaec315b4605d11462a2991819fdeff950c2f94917f822007ef2623f45a6f1f802b1d28f2cb97b3f5c8f6bcc1bb65fc4da32203536f012c664aa8a3e54bc2e6b5a68e135b3b6ba0378bfa35a6821703f70ce8b0ee3348a9973433269239b4fe7c31138d28fc8cadee65c849e7997d40abcf200e2accb52bb344ae15d6ddc74b9bda8ebab84eb4123cecfb41befce0bf587fbcc53288d187c32df8d4b2321ae37d538e0f8798954075f978f30d2484a46d005139df5bab27c80bfd4bcb57bfd03b213df2a37d6ddf69492faca01a7e34c865d662679b245d653cd3ba183f286d0483b8d62b9e7a162973faf6941075a6fbb597948c155568ba06703a3a1360a8849190b3e1ab64c971522c3ea1ac2324af0de0da8441a1686623a3dbcf1009779c7f2c057ddd94a143484ad1fad90394b606032993b0dee255ff6427b26b425c90feb3c019fbbfc71ef586d2c8bf5245f4d11887accc717b437d759cf504491aed629b7e9d004df09a7c41ca51ab18041a1be87213e30d60d624edec095badc7c64718a0961ba834ed0101ada6f027e426a3c795acec7fa785daa3392c88b75c40022e6e369fa16d062961dfe9a434dcbec2a3b16c820a87c575ba7c414b16ecde7072257360a850d5ba5cb5153ccf00478936ae3914310fdfbd3f35f107330474335c3539c4f4c16dadff4b1df430b558166d02f0665122b640051d7bdbc2db7dafb7d0241a8d2a39fea73124329d7053855a757a9befe851e5b5c9191c2e8601a391f6dbbf6523c7bd60e74b63cce28cc94a6d272117caec62b52a989b5b43d1c89e5d2ead44fe5dc4c9bbf1541d8cc4d0530804dc332fa0c65c8dceb2c9b4ec9579e68f268fc580c6621c93488efcdb9378d52f6916076dcf68e701e9a595d43239a5dbc8971675c93a17b06ce08767cad88602e28184fe13b0f83cc17c58ab1117c010b016bd4d0b21b7f31ef7475f00450796fd426d9bf16311d919aa0e7a59bf7c45e1d0c0701f3b5d3281760bb3bdc479750cf5706ad0b452d2d0ab490071b184074fbf4b33b5ee2b4b3763f482c1770d6f811042877722941a046b64775c4432cdbc4736386a05695900dcb393cb81aa30c376f8ec37d02ee368118cf38c7e67cd87ca31a18782f1f32608ca9f51576295693333fccb8dfb003ef8961465cc030a6d8070a8e774e68d85e2c3ea06bd4daf739755f08fa422108a0014ab725013e984e1866880f0d7bd0f3cfe540d7a3396ba7a3d1538dee3a1b525bc0bb1dc470dd6b32ba77b429438161057da100f34194b4cbb1ecc8ff118ab9738a907bd2efa35b2eb43ad512b6dd42049c8b3112025ec3ed0e681303b9865360d8d0b680dcb3d8ab516efc1a2bda5f2e909ec27262017fcc84c2fec0c53b693639668ba92f93d4004eb332a127f0e6a4065efe16961436ba59358130058cdc06b70ed71128cdb706a50cfa38c027d8ecb62de425eeabf1f385572019ca430637e05c468c771d035b455a0f255040de7288fc7c56278a20835fd2a34e30359a56d8025aa9eb0a0952c9dda25ab3948b9abe8c0b88e45751c0ad40b5473fbb7485bec2154b2d44a888b3e762fdd2a5723e523b50c9299b8c27782d1dc16d53123858f540686a8eb0100f90d307340089333daccfe5868973593f3c1bc02cf5d3ffe12e0bbd2d285fbc0f27ad7eb75c8df682ede5310729c3f9540536ccf4e67a611c365166eadff1493a2223bbad46e2a9ae511a3cd070f3e6c8539b7fffb4823fb8153b609e2486c9e7838631b89afa65f5ea5859b8739e9d49d3117fc222b796010c7d03098ae875ec32d3e7d4f47cbd3b8bf70d87b04981a6234a0ad71e302c61924f97b06dea0f5651c781b7e9ed38b570708a417813604c1ad44464f1958960405a36e28d39396c4a04a1e72cd7af1c645b8e6bb12ca05d68dad938072df2ce96a3397122b9a11ee8bd04b70d0c0df332aa7e7c330f742336cb2d131ad01ec7a6bc4d1a173f920b699026fbd12e50db6bac8dafeadab74192b12a37d97deff2867bf92ec023fdbfe0a89fc6c73a95a5b40af0d2613a118bb2ecc356821a827acac4da0f4b82a0982c9e56750e37b52361f16e2b42feaf1a0a9e26e48610cea20e273da95b16adb5e9b1a0a5176e00093d862d4c4d52d44cce852da0ecf321d830615fb06feac7d96b4b04c7ea249c32f67d10f63d0c17e34f1576ab9d849fb778b823c19107e63c92362e5619a1dec59ca59903e31ae190db7ffcc98dec7209516db662f54fd815f4e540cf449739ad813ecc2cef5de260cd940c03581f3caa4a2a9f7b45949542a5142cdbd8288a51f6e4bdce4c28172b89cb001f4aa96c67d1f300785ea18da05958015f9827b1a29dfb2e6202574a8dd9b986f4cc6fc88c2a5b9405cb56595e81bd6598d6e0078dac556fad2bc3684109ef76326930581aa8db8bd55755057911eef4efff5a752204b4cfdeb1eb6c483e786ded90e7edff18bb15a5dc4695884309f52ca03283fd1502193ff4e631e2160541aaa0e025391ca5864b61e8d83953e2322a473abb176d4c43fd8a636873d66e4ea37ad0365f88828a0c8fff73dbe53376bdb71380a7c4309d1dd6ba0c36d687f67bf1e36af73dc94441c612e2ce432a72760545c0b668e69651ed3dfacec37ce28dd2e5f66e680d06cb055d5e8493fc9d95f5d76ba344687c202d679c5f86a3b534d37ff8e02843a8325b11c6bec7f83919cec3aed8582750db4d39b80c0e1366dba507e2156c464e62f3d59e997c537a6110a2304355cf8136fb4a189f369c12f991c78c88f128b8d4ea2ed1af224056aab0d0b016b00d78a356de4eae50029b8fbb30c676543264305395fd0e6305be10cf1728479dd54ecb1cedd46a2ed0248048a7e56579b7e0e70b03b8386f36981c6de3a7720143dbe2e6569145296751a4f39d9115381a47b22d2614aaa4d7fe8bbdb9f90920331aa4029b06c6bd688febfa5f6d22f5cf823bd1294f15d8c42e50146fad1f74e7c0be6a75ce2f94bac9130b403acf6bcd57c333c19d03dab1dd1a3fb97a67a3897ad01f536a97bb1430ca9a63bcca25894d3325d0f110d02c5fa1eae47a9a7a523fa3fa4207bbc978e10c3f2ab3673b86569d0a29b15aa1e250a96d9957ed1abb394bd78cfc336048af45dddc4b53e358521c71a20e37dcd57f963a794615f588dba27122433c359e70b067b184e5285812f6643e4a4c3047f0783a8c0d45f6833c96bf3f120044c9e0e7a93c1582be2a245547db9489b125c5ff29e15ee202406aaf00a86bf951461c3f0ee12df909d247e8378a8956733ee2a2551015534512076885d09aa4da4da239da929da894ac217c848b621960b6a3afcfbec2c9fabeca80a24fa65355350c3415938a8853c267c1e6b95113dcc49a8a050a3b8c9bdb56725512b79416de36ac7238dd9fe52abd8aa48f40e99f0a9f2742a258845c5a5654c6038e36388b1d985f5e00dc5444b6ce8e0777c4a7119f02e9d78592c51e2e79cd9694743a463158644b575867093aaab84dfff98e72309104100bbe17251c5fae60917718c9b3f8a91c172677311f965b0824410c9c990ffe5f86611ff5e365d08709ce07609790bb7d496e491812dee093734e2cde70055d9d1e6150c7a34cb914da747adc94210f6e9f3ad5bfaecd97def7953ff0bff80a5936febbf7e71ecb55abf3a383f3a4c7ac6880c1ae35307528c23c8a73cf65c3294c444f7f26d0fde8cd33053378c0bfc3decfca4782f35cdfd205b7cfdbcf1e55ea59650ac51502a8eb1933233b0a698d83c91f3b14336ba5fd759949604b4297b262b24c8d69f17a617fd8addc5f4fa17f2516c258c788de4f0363e2d6b05e0322bb051e244e7667ab354c5081de38da914d518d7c4e9652bd9b44d4809608df8629c07edd307ca157df010c5af47c9454c3debfc59c8793431a22f932df875426012318a7d5b4eca174be9acff4144a3421f0b7bc924f55df1669e86e6d0762d5cd7ebfa1d6597141d04c8709ffbdd5b8a867c7128400a67cd2797aac38830e9df85ecd969ddcf7d071fb587f58d0f9c3645a247208aa7dad14b3b5022fd54b50547bc8e09f859b434c44be09cd91d61f3d16b5f89980a27f15e143100076d383f63430cff25b02ef74d283d114122adcf8cadb9957372e586eb24a2699fb8f91244d47e3bf29f563c21cf8d33322449a038e9fc4134c55f385d81464735c33d179ce9b89bb378ff3912751be79054990c23302389e382b55a9f3040a422c4835e947a0bf581cee7e0df69882f5e74e10304a1365972b29739261c9df2a4195f86d6196bf1ead9e1dd52cc8af53f03c0d95aad7368b4f5a9d0ae1efca1896453e55a5ae7b91d5b19cfbfa80187be8d48dd05ae134486d8a3e37b457f360cb846bb15a82680edb8c4697a34856db060270c0b2ff09c12cc86fc2f703189970c5c715e3553095d16077bd7b182d0a3cdaa65ef31949080aca97c0362c6bd766cd4d201d49b30fdf3537dbe7dc7f8979a4f27b31dda6982b4cf53e699e2436dd0ded82661eeea90ec2dcb9b6565337ac0a37066d9b9ebcac6b6f627d5bf50546f0f0eaab6c660036649d908cad32becdd363bc7230255555de78159db95632692165b014f0b969daf8de13ff27530daae29979dc093c982d2a77cb3d4a864bce36695a649f26cbdd9554a544d70269875e3c65fcc10199bde9cbbf33c2b93eff695b3d18850f90ea285cb3a01ee05dd839d297c1a25314601c38c38964cddd3d1b19cc4a49bfb2c5c11ece83acff49c4365f117165f1e097149359bb84d70b8dbd747953534f86e14320e202269f57ce548ebe9ecc1b96042968a901029faf9b14b05310138222c692041530fe949f3486cd1888930c6fb5be878c312280cfe42be88648098e0e752d2fa2b79db89f20742e587361cddb1af905c55a15e6d236a6f9b6435a327c2a980c74c1f2c80f61e09788e0c03fba989057454f09708ed4d7fc7dcf9e04e2904318fe50d183e30448fbdde0be586f22788c0994b8f4d5d1354c812a7d417ec356bd35b20bb53e9db2684b6ba41508dd5ffb282475581ad60d028f3e7faa7db6e2dfd8665736ceb0d46bfbff88c0539aee1e197ff2dd4504b0e9e13c68adf224dc866086d37f8576eee47fa30f0bf09447b8bcb1c1bc5c26a611d73c9a07c0063382249b51bd3a9ba1f09ab1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"414a6f51bebf16788608c4a5ab2bffa2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
